function [e, H, F] = fnct_PBCFLAF_NLMS(x, d, F)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ON-LINE FUNCTION: PRIORITY-BASED COLLABORATIVE FUNCTIONAL LINK ADAPTIVE
% FILTER (PBCFLAF) USING NORMALIZED LEAST MEAN SQUARES (NLMS) ALGORITHM.
%
% 30 May 2013
% Danilo Comminiello
%
% Department of Information, Electronic and Telecommunication Engineering 
% 'Sapienza' University of Rome
% Via Eudossiana,18, I-00184 Roma, Italy
%
%
% DESCRIPTION:
% Combination of a linear NLMS filter and three nonlinear FLAF.
% Each nonlinear FLAF results from the convex combination with an all-zero 
% kernel.
% The NLMS filter is updated using the overall error signal, while the
% nonlinear filters are updated using the local error signals.
%
%
% INPUT PARAMETERS:
%   x: input signal sample at n-th time instant
%   d: desired signal sample at n-th time instant
%   F.M: filter length
%   F.muNLMS: step size of the NLMS filter
%   F.muFL: step size vector for the nonlinear FLAFs [3,1]
%   F.exord: expansion order vector [3,1]
%   F.memord: memory order - memord = 0 for memoryless functional links
%   F.Mi: vector containing the lengths of the FL input buffers [3,1]
%   F.Me: vector containing the lengths of the expanded buffers [3,1]
%   F.deltaNLMS: regularization parameter of the NLMS filter
%   F.deltaFL: regularization parameter of the FL nonlinear filter
%   F.exord2: number of different sin and cos for each sample
%   F.xBuff: input buffer [M x 1] at time instant n-1
%   F.wNLMS: coefficient vector for the NLMS filter [M x 1] at time instant
%       n-1
%   F.wFL: coefficient vector for the FL filter [Me x 1] at time instant
%       n-1
%   F.a: adaptation parameter vector [1,3] at time instant n
%   F.pa: power factor vector [3,1] at time instant n-1
%   F.mua: step size vector of the adaptation parameters [3,1] at time
%       instant n-1
%   F.beta: power combination factor
%
% OUTPUT PARAMETERS:
%   e: error signal sample at n-th time instant
%   H: shrinkage parameter vector [1,3] at time instant n+1
%   F.M: filter length
%   F.muNLMS: step size of the NLMS filter
%   F.muFL: step size vector for the nonlinear FLAFs [3,1]
%   F.exord: expansion order vector [3,1]
%   F.memord: memory order - memord = 0 for memoryless functional links
%   F.Mi: vector containing the lengths of the FL input buffers [3,1]
%   F.Me: vector containing the lengths of the expanded buffers [3,1]
%   F.deltaNLMS: regularization parameter of the NLMS filter
%   F.deltaFL: regularization parameter of the FL nonlinear filter
%   F.exord2: number of different sin and cos for each sample
%   F.xBuff: input buffer [M x 1] at time instant n
%   F.wNLMS: coefficient vector for the NLMS filter [M x 1] at time instant
%       n
%   F.wFL: coefficient vector for the FL filter [Me x 1] at time instant
%       n
%   F.a: adaptation parameter vector [1,3] at time instant n+1
%   F.pa: power factor vector [3,1] at time instant n
%   F.mua: step size vector of the adaptation parameters [3,1] at time
%       instant n
%   F.beta: power combination factor
%
%
% REFERENCES: 
%   [1] D. Comminiello, L.A. Azpicueta-Ruiz, M. Scarpiniti, A. Uncini and 
%       J. Arenas- García, "Functional Link Adaptive Filters for 
%       Nonlinear Acoustic Echo Cancellation", in IEEE Transactions on 
%       Audio, Speech and Language Processing, vol. 21, no. 7, pp. 
%       1502-1512, July 2013.
%   [2] D. Comminiello, L.A. Azpicueta-Ruiz, M. Scarpiniti, A. Uncini and 
%       J. Arenas- García, "Functional Links Based Architectures for 
%       Nonlinear Acoustic Echo Cancellation", HSCMA' 11, Edinburh, UK, 
%       May 2011.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------Initialization-----------------------------------------------------------%
normFL = zeros(3,1);                                                                % Initialization of the vector containing the norm of the expanded buffers
yFL = zeros(3,1);                                                                   % Current FLAF output sample vector initialization
eFL = zeros(3,1);                                                                   % Current FLAF error sample vector initialization

%----------Update input signal buffer-----------------------------------------------%
F.xBuff(2:F.M) = F.xBuff(1:F.M-1);                                                  % Shift temporary input signal buffer down
F.xBuff(1) = x;                                                                     % Assign current input signal sample

%----------Functional link expansion------------------------------------------------%
gC = flex(F.xBuff, F.Mi(1), F.Me(1), F.exord(1), F.memord, 2);                      % Generate the expanded buffer by using Chebyshev expansion
gT = flex(F.xBuff, F.Mi(2), F.Me(2), F.exord(2), F.memord, 1);                      % Generate the expanded buffer by using trigonometric expansion
gL = flex(F.xBuff, F.Mi(3), F.Me(3), F.exord(3), F.memord, 3);                      % Generate the expanded buffer by using Legendre expansion

%----------Compute individual output signals----------------------------------------%
normNLMS = F.xBuff'*F.xBuff + F.deltaNLMS;                                          % Norm of the input layer vector for the NLMS filter
normFL(1) = gC'*gC + F.deltaFL;                                                     % Norm of the input layer vector for the first FLAF
normFL(2) = gT'*gT + F.deltaFL;                                                     % Norm of the input layer vector for the second FLAF
normFL(3) = gL'*gL + F.deltaFL;                                                     % Norm of the input layer vector for the third FLAF
yNLMS = F.wNLMS'*F.xBuff;                                                           % Compute the output signal for the NLMS filter
yFL(1) = F.wFL1'*gC;                                                                % Compute the output signal for the first FLAF
yFL(2) = F.wFL2'*gT;                                                                % Compute the output signal for the second FLAF
yFL(3) = F.wFL3'*gL;                                                                % Compute the output signal for the third FLAF
eFL(1) = d - (yNLMS + yFL(1));                                                      % Compute the error signal for the first FLAF
eFL(2) = eFL(1) - yFL(2);                                                           % Compute the error signal for the second FLAF
eFL(3) = eFL(2) - yFL(3);                                                           % Compute the error signal for the third FLAF
    
%----------Compute the shrinkage parameter------------------------------------------%
for i = 1:3                                                                         % Limit the adaptation parameter
    if abs(F.a(i)) > 4                                                              % Find elements out of limits
        F.a(i) = sign(F.a(i))*4;                                                    % Replace the wrong element
    end
end
H = logsig(F.a);                                                                    % Compute the shrinkage parameters
F.pa = F.beta*F.pa + (1 - F.beta)*(yFL.^2);                                         % Power normalization estimation

%----------Compute overall output and error signals---------------------------------%
y = yNLMS + H*yFL;                                                                  % Overall output signal
e = d - y;                                                                          % Overall error signal

%----------Update the filters-------------------------------------------------------%
F.wNLMS = F.wNLMS + (F.muNLMS/normNLMS)*e*F.xBuff;                                  % Update of the NLMS filter
F.wFL1 = F.wFL1 + (F.muFL(1)/normFL(1))*eFL(1)*gC;                                  % Update of the first FLAF
F.wFL2 = F.wFL2 + (F.muFL(2)/normFL(2))*eFL(2)*gT;                                  % Update of the second FLAF
F.wFL3 = F.wFL3 + (F.muFL(3)/normFL(3))*eFL(3)*gL;                                  % Update of the third FLAF

%----------Update the adaptation parameter------------------------------------------%
F.a = F.a + (F.mua./F.pa)'*e.*yFL'.*H.*(1 - H);                                     % NLMS adaptation of the mixing parameter
